/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

package com.android.tools.build.bundletool.device;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.google.common.collect.ImmutableSet.toImmutableSet;

import com.android.bundle.Commands.ApkDescription;
import com.android.bundle.Commands.ApkSet;
import com.android.bundle.Commands.BuildApksResult;
import com.android.bundle.Commands.ModuleMetadata;
import com.android.bundle.Commands.Variant;
import com.android.bundle.Devices.DeviceSpec;
import com.android.bundle.Targeting.ApkTargeting;
import com.android.bundle.Targeting.VariantTargeting;
import com.android.tools.build.bundletool.exceptions.CommandExecutionException;
import com.android.tools.build.bundletool.exceptions.ValidationException;
import com.android.tools.build.bundletool.model.ModuleSplit;
import com.android.tools.build.bundletool.model.ZipPath;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

/** Calculates whether a given device can be served an APK generated by the bundle tool. */
public class ApkMatcher {

  private final SdkVersionMatcher sdkVersionMatcher;
  private final AbiMatcher abiMatcher;
  private final ScreenDensityMatcher screenDensityMatcher;
  private final LanguageMatcher languageMatcher;
  private final Optional<ImmutableSet<String>> requestedModuleNames;
  private final boolean matchInstant;

  public ApkMatcher(DeviceSpec deviceSpec) {
    this(deviceSpec, Optional.empty(), /* matchInstant= */ false);
  }

  /**
   * Constructs an ApkMatcher, with a given device configuration, set of splits to match, and an
   * option to match instant splits.
   */
  public ApkMatcher(
      DeviceSpec deviceSpec,
      Optional<ImmutableSet<String>> requestedModuleNames,
      boolean matchInstant) {
    checkArgument(
        !requestedModuleNames.isPresent() || !requestedModuleNames.get().isEmpty(),
        "Set of requested split modules cannot be empty.");
    this.sdkVersionMatcher = new SdkVersionMatcher(deviceSpec);
    this.abiMatcher = new AbiMatcher(deviceSpec);
    this.screenDensityMatcher = new ScreenDensityMatcher(deviceSpec);
    this.languageMatcher = new LanguageMatcher(deviceSpec);
    this.requestedModuleNames = requestedModuleNames;
    this.matchInstant = matchInstant;
  }

  /**
   * Returns all APKs that should be installed on a device.
   *
   * @param buildApksResult describes APKs produced by the BundleTool
   * @return paths of the matching APKs as represented by {@link ApkDescription#getPath()}
   */
  public ImmutableList<ZipPath> getMatchingApks(BuildApksResult buildApksResult) {
    Optional<Variant> matchingVariant = getMatchingVariant(buildApksResult);

    return matchingVariant.isPresent()
        ? getMatchingApksFromVariant(matchingVariant.get())
        : ImmutableList.of();
  }

  private Optional<Variant> getMatchingVariant(BuildApksResult buildApksResult) {
    ImmutableList<Variant> matchingVariants =
        buildApksResult
            .getVariantList()
            .stream()
            .filter(variant -> isVariantInstant(variant) == matchInstant)
            .filter(variant -> matchesVariantTargeting(variant.getTargeting()))
            .collect(toImmutableList());

    // It would be a mistake if more than one variant matched.
    return matchingVariants.isEmpty()
        ? Optional.empty()
        : Optional.of(Iterables.getOnlyElement(matchingVariants));
  }

  private ImmutableList<ZipPath> getMatchingApksFromVariant(Variant variant) {
    ImmutableList.Builder<ZipPath> matchedApksBuilder = ImmutableList.builder();

    Predicate<String> moduleNameMatcher = getModuleNameMatcher(variant);

    for (ApkSet apkSet : variant.getApkSetList()) {
      String moduleName = apkSet.getModuleMetadata().getName();
      boolean isInstallTimeModule = !apkSet.getModuleMetadata().getOnDemand();

      for (ApkDescription apkDescription : apkSet.getApkDescriptionList()) {
        ApkTargeting apkTargeting = apkDescription.getTargeting();
        boolean isSplit = !apkDescription.hasStandaloneApkMetadata();

        if (matchesApk(apkTargeting, isSplit, isInstallTimeModule, moduleName, moduleNameMatcher)) {
          matchedApksBuilder.add(ZipPath.create(apkDescription.getPath()));
        }
      }
    }

    return matchedApksBuilder.build();
  }

  private Predicate<String> getModuleNameMatcher(Variant variant) {
    if (requestedModuleNames.isPresent()) {
      validateVariant(variant);

      ImmutableMultimap<String, String> moduleDependenciesMap = buildAdjacencyMap(variant);

      HashSet<String> dependencyModules = new HashSet<>(requestedModuleNames.get());
      for (String requestedModuleName : requestedModuleNames.get()) {
        addModuleDependencies(requestedModuleName, moduleDependenciesMap, dependencyModules);
      }
      return dependencyModules::contains;
    } else {
      return Predicates.alwaysTrue();
    }
  }

  private void validateVariant(Variant variant) {
    if (requestedModuleNames.isPresent()) {
      Set<String> unknownModules =
          Sets.difference(
              requestedModuleNames.get(),
              variant
                  .getApkSetList()
                  .stream()
                  .map(ApkSet::getModuleMetadata)
                  .map(ModuleMetadata::getName)
                  .collect(toImmutableSet()));
      if (!unknownModules.isEmpty()) {
        throw ValidationException.builder()
            .withMessage(
                "The APK Set archive does not contain the following modules: %s", unknownModules)
            .build();
      }
    }
  }

  /** Builds a map of module dependencies. */
  private static ImmutableMultimap<String, String> buildAdjacencyMap(Variant variant) {
    ImmutableMultimap.Builder<String, String> moduleDependenciesMap = ImmutableMultimap.builder();
    variant
        .getApkSetList()
        .stream()
        .map(ApkSet::getModuleMetadata)
        .forEach(
            moduleMetadata -> {
              moduleDependenciesMap.putAll(
                  moduleMetadata.getName(), moduleMetadata.getDependenciesList());
              moduleDependenciesMap.put(moduleMetadata.getName(), "base");
            });
    return moduleDependenciesMap.build();
  }

  /** Adds module dependencies to {@code dependencyModules}. */
  private static void addModuleDependencies(
      String moduleName,
      Multimap<String, String> moduleDependenciesMap,
      Set<String> dependencyModules) {
    if (!moduleDependenciesMap.containsKey(moduleName)) {
      return;
    }

    for (String moduleDependency : moduleDependenciesMap.get(moduleName)) {
      // We do not examine again the dependency that was previously handled and added.
      if (dependencyModules.add(moduleDependency)) {
        addModuleDependencies(moduleDependency, moduleDependenciesMap, dependencyModules);
      }
    }
  }

  /** Returns whether a given APK generated by the Bundle Tool should be installed on a device. */
  private boolean matchesApk(
      ApkTargeting apkTargeting,
      boolean isSplit,
      boolean isInstallTimeModule,
      String moduleName,
      Predicate<String> moduleNameMatcher) {
    boolean matchesTargeting = matchesApkTargeting(apkTargeting);

    if (isSplit) {
      return matchesTargeting
          && ((isInstallTimeModule && !matchInstant) || moduleNameMatcher.test(moduleName));
    } else {
      if (matchesTargeting && requestedModuleNames.isPresent()) {
        throw CommandExecutionException.builder()
            .withMessage("Cannot restrict modules when the device matches a non-split APK.")
            .build();
      }
      return matchesTargeting;
    }
  }

  private boolean matchesApkTargeting(ApkTargeting apkTargeting) {
    return sdkVersionMatcher
        .getApkTargetingPredicate()
        .and(abiMatcher.getApkTargetingPredicate())
        .and(screenDensityMatcher.getApkTargetingPredicate())
        .and(languageMatcher.getApkTargetingPredicate())
        .test(apkTargeting);
  }

  /**
   * Returns whether a given APK generated by the Bundle Tool matches the device targeting.
   *
   * @return whether the APK matches the device targeting
   */
  public boolean matchesModuleSplitByTargeting(ModuleSplit moduleSplit) {
    return matchesVariantTargeting(moduleSplit.getVariantTargeting())
        && matchesApkTargeting(moduleSplit.getApkTargeting());
  }

  private boolean matchesVariantTargeting(VariantTargeting variantTargeting) {
    return sdkVersionMatcher
        .getVariantTargetingPredicate()
        .and(abiMatcher.getVariantTargetingPredicate())
        .and(screenDensityMatcher.getVariantTargetingPredicate())
        .test(variantTargeting);
  }

  private static boolean isVariantInstant(Variant variant) {
    return variant
        .getApkSetList()
        .stream()
        .flatMap(apkSet -> apkSet.getApkDescriptionList().stream())
        .allMatch(ApkDescription::hasInstantApkMetadata);
  }
}
